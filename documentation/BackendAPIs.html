<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guide to Servers & APIs</title>
    <link rel="stylesheet" type="text/css" href="/stylesheets/samplestyle.css">
</head>
<body>
    <section> <!-- Client-Server Architecture & Server Setup using NPM & NodeJS -->
        <h3>Client-Server Architecture</h3>
        <p>The internet functions the general interaction between clients and servers, which is based on a client-server model.</p>            
        <p>Clients are the computers we use to send requests through an internet service provider to a server.</p>
        <p>Servers are computers that are connected to the internet and respond to requests by returning a response. </p>
        <p>HTTP stands for Hypertext Transfer Protocol and is the standard application-level client-server protocol for allowing the web to be interactive or exchanging files on the internet. The S in HTTPS stands for Secure and that uses separate protocols called SSL (Secure Sockets Layer) and TLS (Transport Layer Security). Sites without the certificate do not encrypt the information that's being sent.</p>
        
        <h4>Request-Response Cycle</h4>
        <p>Requests and responses function similar to sending letters by postal service. Header functions like postage, the path is the address, and the body is the content being sent or recieved.</p>
        <p>HTTP headers allow the client and server to pass additional information with the request or response.
            <ul>
                <li>General Header: includes date and connection status</li>
                <li>Response Header: server and accept-ranges</li>
                <li>Entity Header: content-type, content-length, last-modified</li>
                <li>Document Body: DOM elements</li>
            </ul> 
        </p>
        <p>Activity initiation for the HTTP message cycle is essentially as follows:
            <pre>
                [APIs(script) + UI-Activity(browser-side) + HTML Forms(browser-side) + Config file(server)] -> converted into HTTP/1.x message -> Binary Framing = [Frame Type=HEADERS + Frame Type=CONTINUATION sets + Frame Type=DATA sets]
            </pre>
        </p>

        <p>Requests are formatted using the GET method and a file path.
            <pre>
                GET/domain/path HTTP/1.1
                Host: domain.org
                Accept: application/json, text/javascript, */*
                Accept-Language: en-us
                {
                    "color": purple,
                    "quantity": 1
                }
            </pre>
            <p>GET is the method followed by the domain path.</p>
            <p>Host and accept are included in the header of the request while anything included in the curly braces is the body of the request. N</p>
        </p>
        <p>Responses are formatted as follows:
            <pre>
                HTTP/1.1 200 OK
                Date: Thurs, 01 Jan 1990 18:28:02 GMT
                Server: Apache
                content-Type: text/html
                {
                    "item": "burger"
                    "price": 5
                }
            </pre>
            <p>200 OK is the status message, followed but the header and body with the same formatting as the request.</p>
        </p>
        <p>HTTP Status Codes are shown in the debugger tab in developer tools. 
            <ul>
                <li>100 range - informational response</li>
                <li>200 range - default status code for wworking response</li>
                <li>300 range - redirect notice</li>
                <li>400 range - client-side issue</li>
                <li>500 range - server-side issue</li>
            </ul>
        </p>

        <h4>CRUD Applications</h4>
        <p>Clients generally request four types of actions using methods, they are known as CRUD applications:
            <ul>
                <li>Create data - Post method</li>
                <li>Read data - Get method</li>
                <li>Update data - Put/Patch method</li>
                <li>Delete data - Delete method</li>
            </ul>
        </p>
        <p>CRUD usage in a fullstack-web application
            <ul>
                <li>Create - make a new account</li>
                <li>Read - account details</li>
                <li>Update - edit the account information</li>
                <li>Delete - remove or delete the account</li>
            </ul>
        </p>
        <p>Webpage Interaction Flow
            <ul>
                <li>User requests to see profile</li>
                <li>Server gets request and requests data from the database</li>
                <li>Database locates data then sends the data back to the server
                    <pre>
                        member = {
                            name: 'John',
                            image: 'Profile-John.jpg',
                            dateJoined: 'April 1, 2022'
                        }
                    </pre>
                </li>
                <li>Server gets data and combines it with HTML
                    <pre>
                        &lt;section>
                            &lt;img src="{member.image}" alt="{member.name}">
                            &lt;h4>{member.name}&lt;/h4>
                            &lt;h5>&lt;span>Date Joined: &lt;/span>{member.dateJoined}&lt;/h5>
                        &lt;/section>
                    </pre>
                </li>
                <li>Server sees their profile. Will return card with Picture, name, and date joined.</li>
            </ul>
        </p>


        <h4>Parts of a URL</h4>
        <p>URLs are comprised of 5 main parts
            <pre>https://domain.org/path/search?course=topic=url#example</pre>
            <ul>
                <li>Protocol 'https:' - determines what type of protocol is used.</li>
                <li>Host/Domain '//domain.org' - address of server providing resources. Can be IP for local machine.</li>
                <li>Path '/path/search' - server resource path, similar to a file path</li>
                <li>Query String: '?course=topic=url' - parameter passed to the server to provide specific information</li>
                <li>Fragment: '#example' - located at the end, specific section of the response identified by an id.</li>
            </ul>
        </p>

        <h3>Node.js</h3>
        <p>Javascript on the server-side</p>
        <p>Typical use case for Node.js is that it's a JavaScript runtime environment that runs independant from any browser. It can run scripts or server-side code on its own as it runs on the same engine that powers Google Chrome. The environment, behavior, and code are simillar to one another.</p>
        <p>Key differences between front-end javascript and Node.js:
            <ul>
                <li>Javascript runs inside a browser while Node.js functions without need of one.</li>
                <li>Node.js is unable to access the DOM while JavaScript can create and manipulate the DOM elements.</li>
                <li>Node.js comes with a package manager(npm) while Javascript needs libraries for external code. Node packet manager is a public directory of node modules. Packages are one or more related modules that have been grouped together.</li>
                <li>Modules are javascript files with inter-related functionality. 'require' keyword to include modules.</li>
            </ul>
            global 'process' variable to access the environment
            npm has to be installed to access and interpret code that other developers wrote. 
        </p>
        <p>Nodemon is a replacement wrapper for node tool used to monitor changes to your code and automatically restarts your server as needed. To install the tool globally:
            <pre>
                npm install -g nodemon
            </pre>
            then you just run the 'nodemon' command in the terminal to start the server from the project folder directory
        </p>

        <h3>Using the Terminal</h3>
        <p>'npm' to install and require third-party code. 'npm install' can be abbreviated to 'npm i' to acheive the same effect. 
            <pre>
                npm install module-name
            </pre>
            After the command finishes running, there will be a new folder labled 'node_modules', a file named 'package-lock.json', and changes to the 'package.json' file. All of the third-party code is copied and stored in the 'node_modules' folder. 'package-lock.json' file is there for Node.js to keep track of all versions of each dependency and is automatically updated. 
        </p>
        <p>'npm install -g' will install the package globally and the package will be available to access from anywhere on the machine. Unless it's a tool you like to use during development, you generally don't want to do this.</p>
        <p>'npm init' command creates a package.json file which contains metadeta about a project.</p>
        <p>'require' keyword is used to add modules by declaring it in a variable
            <pre>
                const moduleName = require ('module-name')

                console.log(moduleName.random())
            </pre> 
        </p>

        <h3>Web Server Setup</h3>
        <p>Core Modules are built-in modules that contain essential functionality that doesn't need to be installed. Just need to require the module name in an associated variable.</p>
        <p>Important Core Modules
            <ul>
                <li>http - used in creating web servers</li>
                <li>url - URL parsing methods</li>
                <li>path - methods for parsing file paths</li>
                <li>fs - methods for dealing with file inputs/outputs</li>
            </ul>
        </p>
        <p>Simple web server using HTTP core module
            <pre>
                let http = require('http')

                let server = http.createServer(function (req, res) {
                    //callback handles incoming requests when client connects to a server
                    res.write('&lt;h1>Welcome!&lt;/h1>')      //sends data for response

                    res.end()   //closes the connection
                })

                server.listen(3000)     //.listen method is used to watch for connections
            </pre>
            console messages will be displayed in the terminal when the server starts
        </p>
        <p>
            <ul>
                <li>Using the terminal, create a project folder using 'mkdir' and use 'cd with the URL' navigate to that directory.</li>
                <li>Create index.js using 'touch' in the project folder</li>
                <li>Run the command 'npm init-y' </li>
                <li>Run the next command 'npm install express' or 'npm i express'</li>
                <li>Run 'open index.js' to open the file and insert the following to require Express: 
                    <pre>
                        // Require needed modules
                        const express = require('express')
                    </pre>
                </li>
                <li>Initialize the app variable in the index.js file.
                    <ul>
                        <li>Call 'app.get()' - the get() method accepts two arguments, a path(string '/') and a callback function(two parameters for require/'req' and resolve/'res') which represent the HTTP request and response.</li>
                        <li>In the inline callback function, call res.send(). The code in this callback function is what runs when someone visits that path on the website!
                            <pre>
                                //Require needed modules.
                                const express = require('express')
                                
                                //Initialize the app object.
                                const app = express()
                                
                                //Create a homepage route that gets sent to the client/web browser
                                app.get('/', function (req, res) {
                                    res.send('This is on the page')
                                })

                                //Create second route.
                                app.get('/contact', function (req, res){
                                    res.send('Contact Page')
                                })

                                //Listen for connections using '.listen' method. just 'app.listen(3000)' to keep the server open or pass a function 
                                app.listen(3000, function () {  
                                    console.log('Server is active')
                                })
                            </pre>
                        </li>
                    </ul>
                </li>
                <li>Run the command 'nodemon' while in the project folder's directory to start the server</li>
                <li>Open browser and go to following url to test if server is active. Port must match the port number used in app.listen
                    <pre>
                        http://localhost:3000/
                    </pre>
                </li>
            </ul>
        </p>
    </section>

    <section> <!-- About Express & Frameworks -->
        <h3>About Express & Frameworks</h3>
        <p>Frameworks are chunks of code and software that make it easier to write, maintain, and scale web applications by providing tools and libraries to simplify common web tasks or necessary features.</p>
        <p>Popular Frameworks are generally affiliated with a programming language.
            <ul>
                <li>Express - affiliated with Node.js</li>
                <li>Flask - affiliated with Python</li>
                <li>Django - affiliated with Python</li>
                <li>Spring Boot - affiliated with Java</li>
                <li>Laravel - affiliated with PHP</li>
            </ul>
        </p>
        <p>There are two types of frameworks. Monolithic frameworks are prebuilt frameworks that have many built-in features with preset configurations. Modular frameworks similar to building blocks as they are customizable with configuration choices.</p>
        <p>Express is a modular framework that can be installed  like any other node module using 'npm install express' command in the terminal. Like any other node modules, express needs to be required.
            <pre>
                const express = require('express')      //require express
                const app = express()       //initialize express app

                app.get('/', (req, res) => {    //'.get' method ('path', (http request, http response) callback runs while someone visits page)
                    console.log('Connected to server')
                    res.send('WEB Content')
                })

                app.listen(3000)        //connection to web server port that stays open to listen for connections
            </pre>
        </p>

        <h3>Setting up a local web server with Express. Express for Server-Side Rendering(SSR)</h3>
        <p>Model - data that is provided to be combined with HTML</p>
        <p>Views - make views of HTML for users to be able to use a website to perform CRUD process</p>
        <p>Controllers - how the other mentioned processes work in an organized and reusable way</p>

        <h3>Creating a Full-Stack Application</h3>
        <p>Using Express for the server, using JSX to embed data in HTML, plain arrays and objects to simulate data</p>
        <p>Create a new object, Read an index of all objects, Read details of individual objects, Update details about the object, Delete object</p>
        <p>
            <ul>
                <li>Creating a Welcome/Landing Page view with '/' route or path</li>
                <li>Index - List of all objects view with '/objects' path
                    <ul>
                        <li>Create New Object view with '/objects/new' path; Form with Submit button</li>
                        <li>Show Object Details view with show details '/objects/:id' with edit and delete button options
                            <ul>
                                <li>Edit Object view with '/objects/:id/edit' path; edit form and submit button</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </p>
        <p>Project Folder format
            <ul>
                <li>'controllers' folder
                    <ul>
                        <li>'controller.js' file</li>
                    </ul>
                </li>
                <li>'models' folder
                    <ul>
                        <li>'object.js' file</li>
                    </ul>
                </li>
                <li>'public' folder
                    <ul>
                        <li>'main.css' file</li>
                    </ul>
                </li>
                <li>'views' folder
                    <ul>
                        <li>'components' folder
                            <ul>
                                <li>'form.jsx' file</li>
                            </ul>
                        </li>
                        <li>'layouts' folder</li>
                        <li>404.jsx</li>
                        <li>edit.jsx</li>
                        <li>index.jsx</li>
                        <li>new.jsx</li>
                        <li>show.jsx</li>
                    </ul>
                </li>
                <li>'.gitignore' file</li>
                <li>'package-lock.json' file</li>
                <li>'server.js' file</li>

            </ul>
        </p>

        <h3>Scaling using Express</h3>
        <p>'GET' and 'POST' are methods. 'GET' provides public information as unencrypted visible data. 'POST' method on the other hand provides more secure encrypted not visible data. </p>
        <p>On the client-side, there are multiple ways to generate a GET request.
            <ul>
                <li>Submitting a form that uses the "GET" method
                    <pre>
                        &lt;form action="/search" method="GET">     //"/path" followed invoked method
                            &lt;label for="query">Query&lt;/label>
                            &lt;input id="query" name="term">      //term = queried data
                        &lt;/form>
                    </pre>
                    In the Express app: 
                    <pre>
                        app.get('/search', (req, res) =>{
                            let item = req.query.term
                            res.send('Search Results for ', item)
                        })
                    </pre>
                </li>
                <li>Using a hyperlink
                    <pre>
                        &lt;a href="/contact">Contact Us&lt;/a>
                    </pre>
                </li>
                <li>Typing into browser's address bar</li>
            </ul>
        </p>
        <p>'POST' method is meant for server-side. The 'app.post() method is used to recieve a POST request.
            <pre>
                &lt;form action="/auth/login" method="POST">
                    &lt;label for="">Login&lt;/label>
                    &lt;input type="text" name="username">
                &lt;/form>
            </pre>
            In the Express app:
            <pre>
                app.post('/auth/login', (req, res) =>{
                    res.send('POST Route')
                })
            </pre>

            Using both GET and POST route for the /auth/login path provides different functionality. 'GET' will render the page with a login form while 'POST' will accept and process data from the login form.
        </p>
        <p>You're able to add routes as needed but it's not best practice as it gets progressively messy when you try to scale an app with more routes. 
            <pre>
                app.get('/auth/login', (req, res) => {
                    res.send('GET route')
                })

                app.post('/auth/login', (req, res) =>{
                    res.send('POST route')
                })

                app.get('/auth/signup', (req, res) => {
                    res.send('GET route')
                })

                app.post('/auth/signup', (req, res) => {
                    res.send('POST route')
                })
            </pre>
            As opposed to creating multiple routes, you can organize or access related routes from a controller. Controllers allow you to organize the routes by purpose in other files besides the index.js file.
        </p>
        <p>Making Controllers
            <ul>
                <li>Create seperate folder named controllers</li>
                <li>Create file 'auth.js'</li>
                <li>In the 'auth.js' file, call express.Router() and attach routes</li>
                <li>'module.exports = router' exports the router from auth.js and import it in index.js
                    <pre>
                        const router = express.Router()

                        router.get('/login', (req, res) => {        //GET method to render page with login form
                            res.send('GET  route')
                        })

                        //Misc Other Routes
                        app.post('/auth/login', (req, res) =>{      //POST method that accepts and processes data from the login form
                            res.send('POST route')
                        })
        
                        app.get('/auth/signup', (req, res) => {     //GET method that renders page with sign-up form.
                            res.send('GET route')
                        })
        
                        app.post('/auth/signup', (req, res) => {        //POST metthod accepts and processes data from the sign-up form
                            res.send('POST route')
                        })

                        module.exports = router     //exports the route to be accessible in other files
                    </pre>
                </li>
                <li>In the index.js file, require the './controllers/auth' path
                    <pre>
                        const express = require('express')
                        const app = express()

                        app.get('/', (req, res) => {        //GET method to send you to the home page.
                            res.send('HOME')
                        })

                        app.use('/auth', require('./controllers/auth'))     //imports the routes into the files

                        app.listen(3000)
                    </pre>
                </li>
            </ul>
        </p>

        <p>As an application becomes larger, more routes may be required. If you visit a route that doesn't exist, you recieve a 404 error in the developer tools debugger tab and the page crashes. To avoid these issues, you create a 'catch-all' route
            <pre>
                app.get('*', (req, res) => {
                    res.send('404 Page; Page under construction or redirect page notice')
                })
            </pre>
            'Catch-all' routes come last, otherwise it will appear instead of the valid routes.
        </p>
        <p>Postman is an app we can use to test routes without writing a full app. Testing an app's functionality using <a href="https://www.postman.com/downloads/">Postman</a>
            <ul>
                <li>Test a route without writing the full app. Download Postman and create an account</li>
                <li>From the home tab, Create New or Create a 'Workspace' if one hasn't been created yet.</li>
                <li>Create a Request</li>
                <li>Select a Method and paste a Route. Wait for response </li>
            </ul>
        </p>
        
        <h3>Routing</h3>
        <p>Environment variables are dynamically named values that affect behavior of running computer and operating systems. They protect private data(like API keys), abstract machine-specific settings(like port choices), avoid hard-coded data in code. They are typically written in all caps like constants. </p>
        <p>Using Environment Variables
            <ul>
                <li>Install node module 'dotenv'</li>
                <li>Create '.env' file</li>
                <li>In the .js file, require and call the config method. Access the .env variable using the global variable process.
                    <pre>
                        require('dotenv').config()
                        const express = require('express')
                        const app = express()

                        app.listen(process.env.PORT)
                    </pre>
                </li>
            </ul>
        </p>
        <p>Creating multiple routes
            <pre>
                //First Route accessible via base URL: http://localhost:3000/
                app.get('/', function (req, res) {
                    res.send('HOME')
                })

                //Second Route accessible via base URL plus path: http://localhost:3000/contact
                app.get('/contact', function (req, res) {
                    res.send('CONTACT US')
                })                
            </pre>

            On a server, instead of defining routes for three separate pages, the process can be combined into one route. 
            <pre>
                app.get('/about/:staff', (req, res) => {
                    res.send(Research ' + req.params.staff')
                })
            </pre>

            Utilizing query parameters allows passing variables as part of the URL path. Query Parameter Example:
            <pre>
                app.get(/square/:x', function (req,res){
                    let x = Number(req.params.x)
                    let result = x * x

                    res.send(`${x} squared is ${result}`)
                })
            </pre>
            //visiting the http://localhost:3000/square/2 yields a page that states 2 squared is 4
        </p>

        <h3>Utilizing query parameters and Strings within routes</h3>
        <p>Query strings are the part of the URL that comes after the question mark. Similar to query parameters, the query strings will only contain public information.
            <pre>
                app.get('/square', function (req, res) {
                    let x = Number(req.query.x)
                    let result = x * X-UA-Compatible

                    res.send(`${x} squared is ${result}`)
                })
            </pre>

            page would be accessed by visiting: http://localhost:3000/square?x=2
        </p>
    </section>

    <section> <!-- Serverside Rendering with JSX -->
        <h3>JSX - JavaScript XML</h3>
        <p>A newer syntax that utilizes a cross between JavaScript and HTML to make it easier to build dynamic webpages based on data</p>
        <p>Key Javascript concepts and syntaxes used: 
            <ul>
                <li>regular functions using the 'function' keyword and arrow functions</li>
                <li>ternary operators are shortcut syntax replacements for 'if' statements and 'if' statements are not available.
                    <pre>
                        let ifStatement = true

                        if (ifStatement) {
                            console.log('is True')
                        } else {
                            console.log('is False')
                        }
                    </pre>
                    would be replaced with:
                    <pre>
                        let ifStatement = true  //what you want to evaluate
                        let activity =  
                        ifStatement
                        ? 'is True'     //if true do this
                        : 'is False'    //else do this

                        console.log(activity)
                    </pre>
                </li>
                <li>.map() array method that returns new array after taking a callback as a parameter. It replaces 'for' loops and 'for' loops are not available.</li>
            </ul>
        </p>

        <h3>Server-Side Rendering Views</h3>
        <p>Adding and showing CSS by making a show view</p>
        <p>Adding CSS</p>
        <p>Making a 404 page/handler for a possible error</p>

    </section>

    <section> <!-- RESTful Routing -->
        <h3>RESTful routes - New & Create</h3>
        <p>REST is an acronym that stands for Representational, State, Transfer. REST applications follow a pattern of creating webpages that perform CRUD.
            <pre>
                Action ->   HTTP Method ->  Route ->        View ->         Description
                INDEX ->    GET ->          /home ->        index.jsx ->    list of objects
                SHOW ->     GET ->          /home/:id ->    show.jsx ->     show details view for object
            </pre>
        </p>
        <p>RESTful Routes create a readable and maintainable patterns while being flexible utilizing HTTP verbs to minimalize the amount of unique paths.</p>
        <p>New & Create; creating new items using a form</p>
        <p>Creating Routes following REST</p>

        <h3>RESTful Routes - Update & Edit</h3>
        <p>Editing an item using a form
            <pre>
                Action ->   HTTP Method ->  Route ->        View ->         Description
                INDEX ->    GET ->          /home ->        index.jsx ->    list of objects
                SHOW ->     GET ->          /home/:id ->    show.jsx ->     show details view for object
                NEW ->      GET ->          /home/new ->    new.jsx ->      form to create object
                CREATE ->   POST ->         /home ->        none ->         Creates a route to the new object in the database and redirects it to another view
            </pre>
        </p>
        <p>Using 'PUT' action to update an item.</p>

        <h3>RESTful Routes - Delete</h3>
        <p>Deleting an item using a form.
            <pre>
                Action ->   HTTP Method ->  Route ->        View ->         Description
                INDEX ->    GET ->          /home ->        index.jsx ->    list of objects
                SHOW ->     GET ->          /home/:id ->    show.jsx ->     show details view for object
                NEW ->      GET ->          /home/new ->    new.jsx ->      form to create object
                CREATE ->   POST ->         /home ->        none ->         Creates a route to the new object in the database and redirects it to another view
                DESTROY ->  DELETE ->       /home/:id       none ->         Deletes route
            </pre>
        </p>
        <p>Using 'method-override' to allow a form to make a delete action</p>
    </section>

    <section> <!-- Model-View-Controller Architecture -->
        <h3>MVC Architecture</h3>
        <p>MVC is an acronym for Model View Controller which is a software architecture that is commonly used to create easily readable and maintainable codes. </p>
        <p>Separation of concerns is a design principle that allows for better sustainability by separating blocks of code by similar functions or affects specific sets of data.
            <ul>
                <li>Data and Data Logic - user information, user info validation, back-end features</li>
                <li>UI & UX - information displayed webpage, alerts and error messages, front-end features</li>
                <li>Controllers - interaction between models and views, provides the error or alert message</li>
            </ul>
        </p> 
        <p>discipline and fundamental structure of a software system(web app)
            <li>Users interact with the <i>views</i></li>
            <li><i>Models</i> define and contain logic and interactive data along with conversions, validations, computed properties, and access control.</li>
            <li><i>Controllers</i> function as the point of contact between the views and models.</li>
        </p>

        <p>REST is an acronym that stands for Representational, State, Transfer. RESTful Routes create a readable and maintainable patterns while being flexible utilizing HTTP verbs to minimalize the amount of unique paths.
            <pre>
                Action ->   HTTP Method ->  Route ->        View ->         Description
                INDEX ->    GET ->          /home ->        index.jsx ->    list of objects
                SHOW ->     GET ->          /home/:id ->    show.jsx ->     show details view for object
                CREATE ->   POST ->         /home ->        none ->         Creates a route to the new object in the database and redirects it to another view
                NEW ->      GET ->          /home/new ->    new.jsx ->      form to create object
                EDIT ->     GET ->          /home/:id/edit  edit.jsx ->     form created from existing object
                UPDATE ->   PUT ->          /home/:id       update.jsx ->   update data for existing form
                DESTROY ->  DELETE ->       /home/:id       none ->         Deletes route
            </pre>
        </p>
        <p>Best practices or Code Refactoring
            <pre>
                var nameFunction = (x) -> {
                    let y = '';
                    if (x == 0 ) y = false; 
                    else if (x === 1) {
                        y = True
                    }else if (x === 2 ) {
                        y = false
                    } else if (x === 4) {
                        y = true
                    } else if ( x == 5 ) {
                        y = false
                    }   //continues to 1000 or more 
                    return y; 
                    }
                }
            </pre>

            <pre>
                let ifEven = number => {
                    console.log(number, number &lt; 0);
                    if (number &lt; 0) {
                        return false
                    } else {
                        return (
                            number == 0
                            ||
                            ifEven(number - 2)
                        )
                    }
                }
            </pre>
            
            <pre>
                const ifEven = (num) => {
                    return num % 2 === 0
                }
            </pre>

            <pre>
                const e = n => n % 2 === 0
            </pre>
        </p>
    </section>

    <section> <!-- MongoDB & NoSQL -->
        <h3>MongoDB & NoSQL</h3>
        <p>Databases are collections of organized and structured data that's stored electronically in a computer and provides high performance in accessing data.</p>
        <p>SQL & NonSQL databases</p>
        <p>MongoDB database structure</p>

        <p>MongoDB stores data as document objects and is classified as a non-relational database. By storing data as objects, this allows for flexibility with custom data structures that don't conform to tables and allows documents within same collections to have different fields.</p>
        <p>MongoDB allows users to create validation rules to avoid formatting variances due to different data sets.
            <pre>
                {_id: ObjectID("109e284fa3401984"),
                name: 'ReadyPlayerOne',
                type: 'Player',
                gender: 'Male',
            </pre>

            <pre>
                {_id: ObjectID("109e284fa335798"),
                name: 'Jarl Banzo',
                type: 'NPC',
                gender: 'Male',
                aggro: false
                catchphrase: 'Welcome to Bratwurst',
            </pre>

            Both documents can be in the same collection of 'characters'
        </p>
    </section>

    <section> <!-- Mongoose & ODMs -->
        <h3>Mongoose & ODMs</h3>
        <p>ODMs are defined as Object Data Mappers. They help with model data while making document validation easier with built-in methods by providing structure and consistency to documents. They allow for queries and CRUD operations to perform within an application code instead of in the Mongo shell. </p>
        <p>'mongoose' is an npm package and also an ODM for MongoDB that simplifies interactions with a Mongo database within node apps by converting Mongo documents into Javascript objects and vice versa.
            <pre>
                JSX(Client application) &lt;--> node.js(server)/express(server) &lt;--> mongoose(server) &lt;--> mongoDB(database) 
            </pre>
        </p>
        <p>Install and connect Mongoose to an Express App in the 'server.js' file
            <pre>
                const mongoose = require('mongoose')
            </pre>
        </p>

        <h3>Mongoose Models and Schemas</h3>
        <p>Models are objects that provide access to the matching collections in Mongo. Mongoose models allow users to interact with the Mongo database.
            <pre>
                Ex: MongoDB Collection "Users" &lt;--> Mongoose Model "User"
            </pre>
        </p>
        <p>Schemas determine the structure of documents within a collection and function like a blueprint.</p>
        <p>Documents are the basic unit of data for Mongo while schemas are the basic building block in Mongoose. 
            <br>Creating a model based on Mongoose schema
            <pre>
                //require mongoose
                const mongoose = require('mongoose')
                const { Schema } = mongoose
                
                //defining schema syntax
                const userSchema = new Schema({
                    username: { type: String },
                    password: String    //same as declaring 'type: String'
                })

                //convert schema into model to interact with Mongo database
                const User = mongoose.model('User', userSchema)
            </pre>
        </p>
        <p>Schemas have built-in validators that are set as a property for a field's object. Built-in validators depend on the field type.
            <pre>
                Data Type       Available Validator
                All             required
                Number          min, max
                String          enum, match, minLength, maxLength
            </pre>

            Usage:
            <pre>
                const objectSchema = new Schema{(
                    name: {
                        type: String, 
                        required: true,     //'required:' property is a validator 
                        min: [0, "Desired string for custom error message when validation fails"],
                        max: 25,        //multiple validators can be used on on one property
                        unique: true    //built-in helper option that checks if value is unique, it accepts the boolean value. If not, then false is the default.
                    }       
                })
            </pre>
        </p>
        
        <h4>Mongoose Helper Methods</h4>
        <p>Mongoose models are objects with built-in helper methods that can perform database actions thru using Mongoose.</p>
        <p>New Mongoose models will also generate an object and each object contains helper methods for performing database actions. Each model will link with a corresponding collection in Mongo (ex: User.findOne() will try to find a document within the Users collection). 
            <pre>
                const User = mongoose.model('User', userSchema)

                //Helper methods are similar to prebuilt methods or functions
                User.findOne()
                User.create()
                User.deleteOne()
                User.updateOne()
            </pre>

            Similar to functions, the parameter or argument passed to the method would still be the conditions for the action and once the action is completed, a promise where you can access the data is returned. 
            <pre>
                User.find({ age: 18 })
                    .then(foundUsers => {
                        console.log(foundUsers)     //returns users that are 18
                    })
            </pre>
        </p>

        <p>All helper methods can take additional arguments as options objects to customize an action as an optional argument. The available options will vary depending on the helper method that was used.
            <pre>
                Destination.find({}, [], { sort: { available_tickets: 4 } })    //{ sort: } is an options object to sort the returned data in ascending numerical order of available_tickets
            </pre>

            <pre>
                Destination.findByIDAndUpdate(req.params.id, { available_tickets: 0 }, { new: true })   //{ new: true } is another options object to return an updated document. 
            </pre>
        </p>

        <h3>Custom Helper Methods: Instance & Static Methods</h3>
        <p>Instance methods are methods that can only be used on instances of a model(document) and also only on documents that have been retreived from a database.</p>

        <p>Static methods are methods that can only be utlized on a model(collection) and able to be used prior to documents being retrieved from the database.</p>
        <p>
            <pre>
                Mongoose Term   -> Mongo DB Equivalent
                Instance        -> Document
                Model           -> Collection
            </pre>

            <pre>//Inside the models/user.js file
                const userSchema = new Schema({     //Define the schema
                    firstName: String,
                    lastName: String,
                    score: Number
                })

                userSchema.methods.fullName = function() {      //Defining instance method: userSchema(affected schema).methods(Mongoose keyword to define instance method).fullName(what to set method name to)
                    return this.firstName + this.lastName
                }

                userSchema.static.getHighScorers = function() {     //Defining static method: userSchema(affected schema).static(Mongoose keyword to define static method).getHighScorers(what to set method name to)
                    return this.find({ score: {$gte: 1000 }})

                }
            </pre>
            
            <pre>//Inside the user_controller.js file 
                User.findByID(id)       //query collection for a user document
                    .then(foundUser => {
                        console.log(foundUser.fullName())   //invoke defined .fullName instance method
                    })

                User.getHighScorers()   //query collection using defined static method
                    .then(foundUsers => {
                        console.log(foundUsers)
                    })
            </pre>
        </p>
        <p>Use case for helper methods</p>


    </section>

    <section> <!-- APIs & Documentation -->
        <h3>APIs & Documentation</h3>
    </section>

    <section> <!-- Cloud Deployment -->
        <h3>Cloud Deployment</h3>
    </section>
    
</body>
</html>