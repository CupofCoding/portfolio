<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guide to Servers & APIs</title>
    <link rel="stylesheet" type="text/css" href="/stylesheets/samplestyle.css">
</head>
<body>
    <section> <!-- Client-Server Architecture & Server Setup using NPM & NodeJS -->
        <h3>Client-Server Architecture</h3>
        <p>The internet functions the general interaction between clients and servers, which is based on a client-server model.</p>            
        <p>Clients are the computers we use to send requests through an internet service provider to a server.</p>
        <p>Servers are computers that are connected to the internet and respond to requests by returning a response. </p>
        <p>HTTP stands for Hypertext Transfer Protocol and is the standard application-level client-server protocol for allowing the web to be interactive or exchanging files on the internet. The S in HTTPS stands for Secure and that uses separate protocols called SSL (Secure Sockets Layer) and TLS (Transport Layer Security). Sites without the certificate do not encrypt the information that's being sent.</p>
        
        <h4>Request-Response Cycle</h4>
        <p>Requests and responses function similar to sending letters by postal service. Header functions like postage, the path is the address, and the body is the content being sent or recieved.</p>
        <p>HTTP headers allow the client and server to pass additional information with the request or response.
            <ul>
                <li>General Header: includes date and connection status</li>
                <li>Response Header: server and accept-ranges</li>
                <li>Entity Header: content-type, content-length, last-modified</li>
                <li>Document Body: DOM elements</li>
            </ul> 
        </p>
        <p>Activity initiation for the HTTP message cycle is essentially as follows:
            <pre>
                [APIs(script) + UI-Activity(browser-side) + HTML Forms(browser-side) + Config file(server)] -> converted into HTTP/1.x message -> Binary Framing = [Frame Type=HEADERS + Frame Type=CONTINUATION sets + Frame Type=DATA sets]
            </pre>
        </p>

        <p>Requests are formatted using the GET method and a file path.
            <pre>
                GET/domain/path HTTP/1.1
                Host: domain.org
                Accept: application/json, text/javascript, */*
                Accept-Language: en-us
                {
                    "color": purple,
                    "quantity": 1
                }
            </pre>
            <p>GET is the method followed by the domain path.</p>
            <p>Host and accept are included in the header of the request while anything included in the curly braces is the body of the request. N</p>
        </p>
        <p>Responses are formatted as follows:
            <pre>
                HTTP/1.1 200 OK
                Date: Thurs, 01 Jan 1990 18:28:02 GMT
                Server: Apache
                content-Type: text/html
                {
                    "item": "burger"
                    "price": 5
                }
            </pre>
            <p>200 OK is the status message, followed but the header and body with the same formatting as the request.</p>
        </p>
        <p>HTTP Status Codes are shown in the debugger tab in developer tools. 
            <ul>
                <li>100 range - informational response</li>
                <li>200 range - default status code for wworking response</li>
                <li>300 range - redirect notice</li>
                <li>400 range - client-side issue</li>
                <li>500 range - server-side issue</li>
            </ul>
        </p>

        <h4>Parts of a URL</h4>
        <p>URLs are comprised of 5 main parts
            <pre>https://domain.org/path/search?course=topic=url#example</pre>
            <ul>
                <li>Protocol 'https:' - determines what type of protocol is used.</li>
                <li>Host/Domain '//domain.org' - address of server providing resources. Can be IP for local machine.</li>
                <li>Path '/path/search' - server resource path, similar to a file path</li>
                <li>Query String: '?course=topic=url' - parameter passed to the server to provide specific information</li>
                <li>Fragment: '#example' - located at the end, specific section of the response identified by an id.</li>
            </ul>
        </p>

        <h3>Node.js</h3>
        <p>Javascript on the server-side</p>
        <p>Typical use case for Node.js is that it's a JavaScript runtime environment that runs independant from any browser. It can run scripts or server-side code on its own as it runs on the same engine that powers Google Chrome. The environment, behavior, and code are simillar to one another.</p>
        <p>Key differences between front-end javascript and Node.js:
            <ul>
                <li>Javascript runs inside a browser while Node.js functions without need of one.</li>
                <li>Node.js is unable to access the DOM while JavaScript can create and manipulate the DOM elements.</li>
                <li>Node.js comes with a package manager(npm) while Javascript needs libraries for external code. Node packet manager is a public directory of node modules. Packages are one or more related modules that have been grouped together.</li>
                <li>Modules are javascript files with inter-related functionality. 'require' keyword to include modules.</li>
            </ul>
            global 'process' variable to access the environment
            npm has to be installed to access and interpret code that other developers wrote. 
        </p>
        <p>Nodemon is a replacement wrapper for node tool used to monitor changes to your code and automatically restarts your server as needed. To install the tool globally:
            <pre>
                npm install -g nodemon
            </pre>
            then you just run the 'nodemon' command in the terminal to start the server from the project folder directory
        </p>

        <h3>Using the Terminal</h3>
        <p>'npm' to install and require third-party code. 'npm install' can be abbreviated to 'npm i' to acheive the same effect. 
            <pre>
                npm install module-name
            </pre>
            After the command finishes running, there will be a new folder labled 'node_modules', a file named 'package-lock.json', and changes to the 'package.json' file. All of the third-party code is copied and stored in the 'node_modules' folder. 'package-lock.json' file is there for Node.js to keep track of all versions of each dependency and is automatically updated. 
        </p>
        <p>'npm install -g' will install the package globally and the package will be available to access from anywhere on the machine. Unless it's a tool you like to use during development, you generally don't want to do this.</p>
        <p>'npm init' command creates a package.json file which contains metadeta about a project.</p>
        <p>'require' keyword is used to add modules by declaring it in a variable
            <pre>
                const moduleName = require ('module-name')

                console.log(moduleName.random())
            </pre> 
        </p>

        <h3>Web Server Setup</h3>
        <p>Core Modules are built-in modules that contain essential functionality that doesn't need to be installed. Just need to require the module name in an associated variable.</p>
        <p>Important Core Modules
            <ul>
                <li>http - used in creating web servers</li>
                <li>url - URL parsing methods</li>
                <li>path - methods for parsing file paths</li>
                <li>fs - methods for dealing with file inputs/outputs</li>
            </ul>
        </p>
        <p>Simple web server using HTTP core module
            <pre>
                let http = require('http')

                let server = http.createServer(function (req, res) {
                    //callback handles incoming requests when client connects to a server
                    res.write('&lt;h1>Welcome!&lt;/h1>')      //sends data for response

                    res.end()   //closes the connection
                })

                server.listen(3000)     //.listen method is used to watch for connections
            </pre>
            console messages will be displayed in the terminal when the server starts
        </p>
        <p>
            <ul>
                <li>Using the terminal, create a project folder using 'mkdir' and use 'cd with the URL' navigate to that directory.</li>
                <li>Create index.js using 'touch' in the project folder</li>
                <li>Run the command 'npm init-y' </li>
                <li>Run the next command 'npm install express' or 'npm i express'</li>
                <li>Run 'open index.js' to open the file and insert the following to require Express: 
                    <pre>
                        // Require needed modules
                        const express = require('express')
                    </pre>
                </li>
                <li>Initialize the app variable in the index.js file.
                    <ul>
                        <li>Call 'app.get()' - the get() method accepts two arguments, a path(string '/') and a callback function(two parameters for require/'req' and resolve/'res') which represent the HTTP request and response.</li>
                        <li>In the inline callback function, call res.send(). The code in this callback function is what runs when someone visits that path on the website!
                            <pre>
                                const express = require('express')  //Require needed modules.
                                
                                const app = express()   //Initialize the app object.
                                
                                //Create a homepage route that gets sent to the client/web browser
                                app.get('/', function (req, res) {
                                    res.send('This is on the page')
                                })

                                //Create second route.
                                app.get('/contact', function (req, res){
                                    res.send('Contact Page')
                                })

                                //Listen for connections using '.listen' method. just 'app.listen(3000)' to keep the server open or pass a function 
                                app.listen(3000, function () {  
                                    console.log('Server is active')
                                })
                            </pre>
                        </li>
                    </ul>
                </li>
                <li>Run the command 'nodemon' while in the project folder's directory to start the server</li>
                <li>Open browser and go to following url to test if server is active. Port must match the port number used in app.listen
                    <pre>
                        http://localhost:3000/
                    </pre>
                </li>
            </ul>
        </p>
    </section>

    <section> <!-- About Express & Frameworks -->
        <h3>About Express & Frameworks</h3>
        <p>Frameworks are chunks of code and software that make it easier to write, maintain, and scale web applications by providing tools and libraries to simplify common web tasks or necessary features.</p>
        <p>Popular Frameworks are generally affiliated with a programming language.
            <ul>
                <li>Express - affiliated with Node.js</li>
                <li>Flask - affiliated with Python</li>
                <li>Django - affiliated with Python</li>
                <li>Spring Boot - affiliated with Java</li>
                <li>Laravel - affiliated with PHP</li>
            </ul>
        </p>
        <p>There are two types of frameworks. Monolithic frameworks are prebuilt frameworks that have many built-in features with preset configurations. Modular frameworks similar to building blocks as they are customizable with configuration choices.</p>
        <p>Express is a modular framework that can be installed  like any other node module using 'npm install express' command in the terminal. Like any other node modules, express needs to be required.</p>

        <h3>Setting up a local web server with Express. Express for Server-Side Rendering(SSR)</h3>
        <p>Model - data that is provided to be combined with HTML</p>
        <p>Views - make views of HTML for users to be able to use a website to perform CRUD process</p>
        <p>Controllers - how the other mentioned processes work in an organized and reusable way</p>
        <p>Steps to setup and build an Express app:
            <ul>
                <li>Create new project directory or navigate to existing project directory or local storage</li>
                <li>Inside the folder create an 'index.js' file</li>
                <li>In the command terminal, navigate to the project folder then run following commands: 
                    <ul>
                        <li>Run the command “npm init -y”</li>
                        <li>Run the command “npm install express”</li>
                    </ul>
                </li>
                <li>Open file 'index.js' and require and initialize the app variable express at the top of the file
                    <pre>
                        const express = require('express')      //require express
                    </pre>
                </li>
                <li>Create the home page route
                    <ul>
                        <li>Call app.get()</li>
                        <li>Set '/' as the path (first arg)</li>
                        <li>Write callback function with req, res</li>
                        <li>Call res.send('hello world') </li>
                    </ul>
                </li>
                <li>Call app.listen(process.env.PORT) to keep server open</li>
                <li>Create a '.env' file with 'PORT = 3000' in the first line.</li>
            </ul>

            Results in the following code inside 'index.js' file: 
            <pre>
                const express = require('express')      //require express as needed node module
                const app = express()       //initialize express app

                app.get('/', (req, res) => {    //'.get' method ('path', (http request, http response) callback runs while someone visits page)
                    console.log('Connected to server')
                    res.send('WEB Content')
                })

                app.listen(process.env.PORT)        //connection to web server port that stays open to listen for connections defined as PORT = 3000 defined by local environment variable.
            </pre>
        </p>

        <h3>Creating a Full-Stack Application</h3>
        <p>Using Express for the server, using JSX to embed data in HTML, plain arrays and objects to simulate data</p>
        <p>Create a new object, Read an index of all objects, Read details of individual objects, Update details about the object, Delete object</p>
        <p>
            <ul>
                <li>Creating a Welcome/Landing Page view with '/' route or path</li>
                <li>Index - List of all objects view with '/objects' path
                    <ul>
                        <li>Create New Object view with '/objects/new' path; Form with Submit button</li>
                        <li>Show Object Details view with show details '/objects/:id' with edit and delete button options
                            <ul>
                                <li>Edit Object view with '/objects/:id/edit' path; edit form and submit button</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </p>
        <p>Project Folder format
            <ul>
                <li>'controllers' folder    //function as the point of contact between the views and models
                    <ul>
                        <li>'controller.js' file    //contains functions you write to control your data. For example convert strings or numbers, round, change or calculate values.</li>
                    </ul>
                </li>
                <li>'models' folder 
                    <ul>
                        <li>'object.js' file    //define and contain logic and interactive data along with conversions, validations, computed properties, and access control</li>
                    </ul>
                </li>
                <li>'public' folder
                    <ul>
                        <li>'main.css' file</li>
                    </ul>
                </li>
                <li>'views' folder  //Defines User Interaction and what they see as a response
                    <ul>
                        <li>'components' folder
                            <ul>
                                <li>'form.jsx' file</li>
                            </ul>
                        </li>
                        <li>'layouts' folder</li>
                        <li>404.jsx</li>
                        <li>edit.jsx</li>
                        <li>index.jsx</li>
                        <li>new.jsx</li>
                        <li>show.jsx</li>
                    </ul>
                </li>
                <li>'.gitignore' file   //files listed will not be uploaded to github. Generally includes node modules and API keys</li>
                <li>'package-lock.json' file    //automatically generated for any operations where npm modifies either the node_modules tree, or package.json</li>
                <li>'server.js' file    //Using Node.js(JavaScript framework for writing server-side applications) to trigger small JavaScript programs from the command line without any browser involved.</li>
            </ul>
        </p>

        <h3>Scaling using Express</h3>
        <p>'GET' and 'POST' are methods. 'GET' provides public information as unencrypted visible data. 'POST' method on the other hand provides more secure encrypted not visible data. </p>
        <p>On the client-side, there are multiple ways to generate a GET request.
            <ul>
                <li>Submitting a form that uses the "GET" method
                    <pre>
                        &lt;form action="/search" method="GET">     //"/path" followed invoked method
                            &lt;label for="query">Query&lt;/label>
                            &lt;input id="query" name="term">      //term = queried data
                        &lt;/form>
                    </pre>
                    In the Express app: 
                    <pre>
                        app.get('/search', (req, res) =>{
                            let item = req.query.term
                            res.send('Search Results for ', item)
                        })
                    </pre>
                </li>
                <li>Using a hyperlink
                    <pre>
                        &lt;a href="/contact">Contact Us&lt;/a>
                    </pre>
                </li>
                <li>Typing into browser's address bar</li>
            </ul>
        </p>
        <p>'POST' method is meant for server-side. The 'app.post() method is used to recieve a POST request.
            <pre>
                &lt;form action="/auth/login" method="POST">
                    &lt;label for="">Login&lt;/label>
                    &lt;input type="text" name="username">
                &lt;/form>
            </pre>
            In the Express app:
            <pre>
                app.post('/auth/login', (req, res) =>{
                    res.send('POST Route')
                })
            </pre>

            Using both GET and POST route for the /auth/login path provides different functionality. 'GET' will render the page with a login form while 'POST' will accept and process data from the login form.
        </p>
        <p>You're able to add routes as needed but it's not best practice as it gets progressively messy when you try to scale an app with more routes. 
            <pre>
                app.get('/auth/login', (req, res) => {
                    res.send('GET route')
                })

                app.post('/auth/login', (req, res) =>{
                    res.send('POST route')
                })

                app.get('/auth/signup', (req, res) => {
                    res.send('GET route')
                })

                app.post('/auth/signup', (req, res) => {
                    res.send('POST route')
                })
            </pre>
            As opposed to creating multiple routes, you can organize or access related routes from a controller. Controllers allow you to organize the routes by purpose in other files besides the index.js file.
        </p>
        <p>Making Controllers
            <ul>
                <li>Create seperate folder named controllers</li>
                <li>Create file './controllers/auth.js'</li>
                <li>In the 'auth.js' file, call express.Router() and attach routes</li>
                <li>'module.exports = router' exports the router from auth.js and import it in index.js
                    <pre>
                        const router = express.Router()

                        router.get('/login', (req, res) => {        //GET method to render page with login form
                            res.send('GET  route')
                        })

                        //Misc Other Routes
                        app.post('/auth/login', (req, res) =>{      //POST method that accepts and processes data from the login form
                            res.send('POST route')
                        })
        
                        app.get('/auth/signup', (req, res) => {     //GET method that renders page with sign-up form.
                            res.send('GET route')
                        })
        
                        app.post('/auth/signup', (req, res) => {        //POST metthod accepts and processes data from the sign-up form
                            res.send('POST route')
                        })

                        module.exports = router     //exports the route to be accessible in other files
                    </pre>
                </li>
                <li>In the index.js file, require the './controllers/auth' path
                    <pre>
                        const express = require('express')
                        const app = express()

                        app.get('/', (req, res) => {        //GET method to send you to the home page.
                            res.send('HOME')
                        })

                        app.use('/auth', require('./controllers/auth'))     //imports the routes into the files

                        app.listen(3000)
                    </pre>
                </li>
            </ul>
        </p>

        <p>As an application becomes larger, more routes may be required. If you visit a route that doesn't exist, you recieve a 404 error in the developer tools debugger tab and the page crashes. To avoid these issues, you create a 'catch-all' route
            <pre>
                app.get('*', (req, res) => {
                    res.send('404 Page; Page under construction or redirect page notice')
                })
            </pre>
            'Catch-all' routes come last, otherwise it will appear instead of the valid routes.
        </p>
        <p>Postman is an app we can use to test routes without writing a full app. Testing an app's functionality using <a href="https://www.postman.com/downloads/">Postman</a>
            <ul>
                <li>Test a route without writing the full app. Download Postman and create an account</li>
                <li>From the home tab, Create New or Create a 'Workspace' if one hasn't been created yet.</li>
                <li>Create a Request</li>
                <li>Select a Method and paste a Route. Wait for response </li>
            </ul>
        </p>
        
        <h3>Routing</h3>
        <p>Environment variables are dynamically named values that affect behavior of running computer and operating systems. They protect private data(like API keys), abstract machine-specific settings(like port choices), avoid hard-coded data in code. They are typically written in all caps like constants. Environment variables are useful as they protect private data like API keys, avoid hard-coded data in code, and allow for abstracting machine-specific settings such as port choice or configurations.
            <pre>
                const express = require('express')
                const app = express()

                app.get('/', function (req, res) {
                    res.send('Hello World!')
                })

                app.listen(3000)
            </pre>
        </p>
        <p>Using Environment Variables
            <ul>
                <li>Install node module 'dotenv'</li>
                <li>Create '.env' file. DO NOT END IN SEMICOLONS.
                    <pre>
                        PORT = 3000
                    </pre>
                </li>
                <li>In the .js file, require and call the config method. Access the .env variable using the global variable process.
                    <pre>
                        require('dotenv').config()      //requires and calls the config method
                        const express = require('express')
                        const app = express()

                        //... any other code goes here

                        app.listen(process.env.PORT)    //accesses the environment variable in the .env file using global variable process.
                    </pre>
                </li>
            </ul>
        </p>
        <p>Creating multiple routes
            <pre>
                //First Route accessible via base URL: http://localhost:3000/
                app.get('/', function (req, res) {
                    res.send('HOME')
                })

                //Second Route accessible via base URL plus path: http://localhost:3000/contact
                app.get('/contact', function (req, res) {
                    res.send('CONTACT US')
                })                
            </pre>

            On a server, instead of defining routes for three separate pages, the process can be combined into one route. 
            <pre>
                app.get('/about/:staff', (req, res) => {
                    res.send(Research ' + req.params.staff')
                })
            </pre>

            Utilizing query parameters allows passing variables as part of the URL path. Query Parameter Example:
            <pre>
                app.get(/square/:x', function (req,res){
                    let x = Number(req.params.x)
                    let result = x * x

                    res.send(`${x} squared is ${result}`)
                })
            </pre>
            //visiting the http://localhost:3000/square/2 yields a page that states 2 squared is 4
        </p>

        <h3>Utilizing query parameters and Strings within routes</h3>
        <p>Query strings are the part of the URL that comes after the question mark. Similar to query parameters, the query strings will only contain public information.
            <pre>
                app.get('/square', function (req, res) {
                    let x = Number(req.query.x)
                    let result = x * X-UA-Compatible

                    res.send(`${x} squared is ${result}`)
                })
            </pre>
            page would be accessed by visiting: http://localhost:3000/square?x=2
        </p>
    </section>

    <section> <!-- RESTful Routing -->
        <h3>RESTful Routing</h3>        
        <p>REST is an acronym that stands for Representational, State, Transfer. RESTful Routes create a readable and maintainable patterns while being flexible utilizing HTTP verbs to minimalize the amount of unique paths.
            <pre>
                Action ->   HTTP Method ->  Route ->        View ->         Description
                INDEX ->    GET ->          /home ->        index.jsx ->    list of objects
                SHOW ->     GET ->          /home/:id ->    show.jsx ->     show details view for object
                CREATE ->   POST ->         /home ->        none ->         Creates a route to the new object in the database and redirects it to another view
                NEW ->      GET ->          /home/new ->    new.jsx ->      form to create object
                EDIT ->     GET ->          /home/:id/edit  edit.jsx ->     form created from existing object
                UPDATE ->   PUT ->          /home/:id       update.jsx ->   update data for existing form
                DESTROY ->  DELETE ->       /home/:id       none ->         Deletes route
            </pre>
        </p>
        <h3>RESTful routes - Index & Show</h3>
        <p>Index & Show; using GET method
            <pre>
                Action ->   HTTP Method ->  Route ->        View ->         Description
                INDEX ->    GET ->          /home ->        index.jsx ->    list of objects
                SHOW ->     GET ->          /home/:id ->    show.jsx ->     show details view for object
            </pre>

            <pre>//INDEX route inside './controllers/objects.js'
                object.get("/", (req, res) => {
                    db.Object.find()
                      // Render index page
                      .then((objects) => {
                        res.render("objects/index", { objects });
                      })
                      // to catch any errors
                      .catch((err) => {
                        console.log(err);
                        res.render("error404"); //renders error 404 page
                      });
                  });
            </pre>

            <pre>//SHOW route inside './controllers/objects.js'
                object.get("/:id", (req, res) => {
                    db.Object.findById(req.params.id)
                      .then((object) => {
                        res.render("objects/show", { object });
                      })
                      // to catch any errors
                      .catch((err) => {
                        console.log(err);
                        res.render("error404"); //renders error 404 page
                      });
                  });
            </pre>
        </p>

        <h3>RESTful Routes - New, Create, Update, & Edit</h3>
        <p>New & Create; creating new items using a form or editing an item using a form using GET or POST
            <pre>
                Action ->   HTTP Method ->  Route ->        View ->         Description
                NEW ->      GET ->          /home/new ->    new.jsx ->      form to create object
                CREATE ->   POST ->         /home ->        none ->         Creates a route to the new object in the database and redirects it to another view
            </pre>

            <pre>//NEW route inside './controllers/objects.js'
                object.get("/new", (req, res) => {
                    res.render("objects/new");
                  });
            </pre>

            <pre>//CREATE route inside './controllers/objects.js'
                object.post("/", (req, res) => {
                    db.Object.create(req.body)
                      .then(() => {
                        res.redirect("/objects");
                      })
                        res.render("objects/index", { objects });
                      })
                      // to catch any errors
                      .catch((err) => {
                        console.log(err);
                        res.render("error404"); //renders error 404 page
                      });
                  });
            </pre>
        </p>

        <p>Using 'PUT' method to update an item & Edit 
            <pre>
                Action ->   HTTP Method ->  Route ->        View ->         Description
                UPDATE ->   PUT ->          /home/:id       update.jsx ->   update data for existing form
                EDIT ->     GET ->          /home/:id/edit  edit.jsx ->     form created from existing object
            </pre>

            <pre>//UPDATE route inside './controllers/objects.js'
                object.put('/:id', (req,res) => {
                    console.log(req.body)
                    if(req.body.pic === ""){
                        req.body.pic = undefined;
                    }
                    if(req.body.city === ""){
                        req.body.city = undefined;
                    }
                    if(req.body.state === ""){
                        req.body.state = undefined;
                    }
                    console.log(req.body)
                    db.Object.findByIdAndUpdate(req.params.id, req.body, {new: true})
                        .then(updatedObject => {
                            res.redirect(`/objects/${req.params.id}`)
                        })
                  })
            </pre>

            <pre>//EDIT route inside './controllers/objects.js'
                object.get("/:id/edit", (req, res) => {
                    db.Object.findById(req.params.id)
                      .then((object) => {
                        res.render("objects/edit", { object });
                      })
                      .catch((err) => {
                        res.render("error404");
                      });
                  });
            </pre>
        </p>

        <h3>RESTful Routes - Delete</h3>
        <p>Using 'method-override' to allows a form to make a delete action
            <pre>
                Action ->   HTTP Method ->  Route ->        View ->         Description
                DESTROY ->  DELETE ->       /home/:id       none ->         Deletes route
            </pre>

            <pre>//DELETE route inside './controllers/objects.js'
                object.delete("/:id", (req, res) => {
                    db.Object.findByIdAndDelete(req.params.id)
                      .then((object) => {
                        res.redirect("/objects");
                      })
                      .catch((err) => {
                        console.log("err", err);
                        res.render("error404");
                      });
                  });
            </pre>
        </p>
    </section>

    <section> <!-- Serverside Rendering with JSX -->
        <h3>JSX - JavaScript XML</h3>
        <p>A newer syntax that utilizes a cross between JavaScript and HTML to make it easier to build dynamic webpages based on data</p>
        <p>Key Javascript concepts and syntaxes used: 
            <ul>
                <li>regular functions using the 'function' keyword and arrow functions</li>
                <li>ternary operators are shortcut syntax replacements for 'if' statements and 'if' statements are not available.
                    <pre>
                        let ifStatement = true

                        if (ifStatement) {
                            console.log('is True')
                        } else {
                            console.log('is False')
                        }
                    </pre>
                    would be replaced with:
                    <pre>
                        let ifStatement = true  //what you want to evaluate
                        let activity =  
                        ifStatement
                        ? 'is True'     //if true do this
                        : 'is False'    //else do this

                        console.log(activity)
                    </pre>
                </li>
                <li>.map() array method that returns new array after taking a callback as a parameter. It replaces 'for' loops and 'for' loops are not available.</li>
            </ul>
        </p>

        <h4>CRUD Applications & Serverside Rendering(SSR)</h4>
        <p>Clients generally request four types of actions using methods, they are known as CRUD applications:
            <ul>
                <li>Create data - Post method</li>
                <li>Read data - Get method</li>
                <li>Update data - Put/Patch method</li>
                <li>Delete data - Delete method</li>
            </ul>
        </p>
        <p>CRUD usage in a fullstack-web application
            <ul>
                <li>Create - Create data using Post method; make a new account</li>
                <li>Read - Read data  using Get method; allows looking at account details</li>
                <li>Update - Update data using Put/Patch method; edit the account information</li>
                <li>Delete - Delete data using Delete method; remove or delete the account</li>
            </ul>
        </p>
        <p>Webpage Interaction Flow
            <ul>
                <li>User requests to see profile</li>
                <li>Server gets request and requests data from the database</li>
                <li>Database locates data then sends the data back to the server
                    <pre>
                        member = {
                            name: 'John',
                            image: 'Profile-John.jpg',
                            dateJoined: 'April 1, 2022'
                        }
                    </pre>
                </li>
                <li>Server gets data and combines it with HTML
                    <pre>
                        &lt;section>
                            &lt;img src="{member.image}" alt="{member.name}">
                            &lt;h4>{member.name}&lt;/h4>
                            &lt;h5>&lt;span>Date Joined: &lt;/span>{member.dateJoined}&lt;/h5>
                        &lt;/section>
                    </pre>
                </li>
                <li>Server sees their profile. Will return card with Picture, name, and date joined.</li>
            </ul>
        </p>        
    </section>

    <section> <!-- Model-View-Controller Architecture -->
        <h3>MVC Architecture</h3>
        <p>MVC is an acronym for Model View Controller which is a software architecture that is commonly used to create easily readable and maintainable codes. </p>
        <p>Separation of concerns is a design principle that allows for better sustainability by separating blocks of code by similar functions or affects specific sets of data.
            <ul>
                <li>Data and Data Logic - user information, user info validation, back-end features</li>
                <li>UI & UX - information displayed webpage, alerts and error messages, front-end features</li>
                <li>Controllers - interaction between models and views, provides the error or alert message</li>
            </ul>
        </p> 
        <p>Discipline and fundamental structure of a software system(web app)
            <li>Users interact with the <i>views</i></li>
            <li><i>Models</i> define and contain logic and interactive data along with conversions, validations, computed properties, and access control.</li>
            <li><i>Controllers</i> function as the point of contact between the views and models.</li>
        </p>        

        <h3>Server-Side Rendering Views</h3>
        <p>Models contain data that combines with HTML</p>
        <p>Views of HTML allow for users to be able to interact with a website to perform CRUD methods. Defined behaviors for Routes included in .jsx files
            <pre>//Navigation layout  to add CSS libraries located in './views/layouts/default.jsx'
                &lt;body>
                    function Default(html) {
                        return (
                            &lt;html>
                                &lt;head>
                                    &lt;title>{html.title || 'Default'}&lt;/title>
                                    &lt;link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha512-NhSC1YmyruXifcj/KFRWoC561YpHpc5Jtzgvbuzx5VozKpWvQ+4nXhPdFgmx8xqexRcpAglTj9sIBWINXa8x5w==" crossOrigin="anonymous" />
                                    &lt;link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/skeleton/2.0.4/skeleton.min.css" integrity="sha512-EZLkOqwILORob+p0BXZc+Vm3RgJBOe1Iq/0fiI7r/wJgzOFZMlsqTa29UEl6v6U6gsV4uIpsNZoV32YZqrCRCQ==" crossOrigin="anonymous" />
                                &lt;/head>
                                &lt;body>
                                    &lt;div className="wrapper">
                                        &lt;header>
                                            &lt;h1>&lt;a href="/objects">ObjectCRUD&lt;/a>&lt;/h1>
                                        &lt;/header>
                                        &lt;div className="container">
                                            {html.children}
                                        &lt;/div>
                                    &lt;/div>
                                &lt;/body>
                            &lt;/html>
                        )
                    }
            </pre>
            
            <pre>//Set up View for Show Route inside './views/show.jsx' basic setup code. 'views' folder is located on same level as package.json.
                const React = require('react')      //require and initialize react variable
                const Default = require('./layouts/Default')    //require and initialize default layout
                
                function Show ({object}) {       //create Show function
                    console.log(object.name)    //confirms object data being recieved in the terminal
                    return (
                        &lt;Default>
                            &lt;h2>Show Page&lt;/h2>
                            &lt;h3>{object.name}&lt;/h3>      //data added to the view
                            &lt;img src="{object.image}" alt="{object.name}"/>     //image data added to the view
                        &lt;/Default>
                        )
                    }
                    module.exports = Show
            </pre>

            when conditionally rendering HTML based on Data:
            <pre>
                const React = require('react')      //require and initialize react variable
                const Default = require('./layouts/Default')    //require and initialize default layout
                
                function Show ({object}) {       //create Show function
                    console.log(object.name)    //confirms object data being recieved in the terminal
                    return (
                        &lt;Default>
                            &lt;h2>Show Page&lt;/h2>
                            &lt;h3>{object.name}&lt;/h3>      //data added to the view
                            &lt;p>
                                and it
                                //ternary operator(?/:) is used as there are no if/else statements in JSX
                                {
                                    object.hasAttribute
                                    ? &lt;span> does &lt;/span>
                                    : &lt;span> does NOT &lt;/span>
                                  }
                                  contain Attribute.
                                &lt;/p>

                            &lt;/p>
                            &lt;img src="{object.image}" alt="{object.name}"/>     //image data added to the view
                            &lt;li>&lt;a href="/objects">Go home&lt;/a>&lt;/li>
                        &lt;/Default>
                        )
                    }
                    module.exports = Show
            </pre>
        </p>
        <p>Controllers define Model and Views behavior.
            <pre>//inside '.controllers/objects_controller.js' to update arguments
                objects.get('/:arrayIndex', (req, res) => {
                    res.render('Show', {
                        object: Object[req.params.arrayIndex]
                    })
                })
            </pre>

            then adding a view to handle 404 errors to redirect back to index
            <pre>
                objects.get('/:arrayIndex', (req, res) => {
                    if (Object[req.params.arrayIndex]) {
                      res.render('Show', {
                        object:Object[req.params.arrayIndex]
                      })
                    } else {
                      res.render('404')
                    }
                  })
            </pre>
        </p>

        <p>Best practices or Code Refactoring
            <pre>//Rough Initial coding without loops using if & else statements
                var nameFunction = (x) -> {
                    let y = '';
                    if (x === 0 ) y = true;     //if == then it will return false since javascript thinks 0 == is falsey
                    else if (x === 1) {
                        y = false
                    }else if (x === 2 ) {
                        y = true
                    } else if (x === 3) {
                        y = false
                    } else if ( x === 4 ) {
                        y = true
                    }   //continues to 1000 or more 
                    return y; 
                    }
                }
            </pre>

            <pre>//Next function written with the if statement and condition
                let ifEven = number => {
                    console.log(number, number &lt; 0);
                    if (number &lt; 0) {
                        return false
                    } else {
                        return (
                            number == 0
                            ||      //logical OR assignment operator
                            ifEven(number - 2)
                        )
                    }
                }
            </pre>
            
            <pre>//Ideal as descriptive variable naming and simplest solution
                const ifEven = (num) => {
                    return num % 2 === 0
                }
            </pre>

            <pre>//Single line function using modular operater, single character variable. Harder to read. 
                const e = n => n % 2 === 0
            </pre>
        </p>
    </section>

    <section> <!--JSON, MongoDB, & NoSQL -->
        <h3>JSON - Javascript Object Notation</h3>
        <p>JSON stands for Javascript Object Notation and is a text-based data structure based on key-value pairs that allow for documents and arrays to be nested within each other.</p>
        <p>JSON is a superset of JavaScript which allows it to integrate nicely as the code is still valid Javascript code. Data Representation Format similar to XML or yamo. Used for most APIs and configuration files.</p>
        <p>Most major languages will have a library or built-in functionality to parse or convert JSON strings into classes or objects in that language.  Used because it's lightweight and easy to read compared to XML. It's cleaner code that doesn't use as many open and closing tags.</p>
        <p>Since JSON is a Data Representation Format, it has to be able to represent certain data types. JSON natively supports strings, numbers(including scientific notation and percentages), booleans, null value, arrays (lists of any of the native data types), objects. JSON does not support octal and hexdecimal values. </p>
        
        <h3>Syntax</h3> 
        <p>Objects are the most used data type within JSON as it allows you to represent values that are key value pairs(you assign a key to the object and a value with a native datatype as a matching key.)</p>
        <p>In order to use JSON, it requires a new file with the .json extension/filetype. Inside of the file you have the valid native datatype. Most of the time you will have an array or an object as the top level of the file and nested inside that will be other values(that can include other objects or arrays).</p>
        <p>To create an object in JSON, you need to open with '{' and close file with a '}' with the key value pairs within them. The format is similar to creating an array in other programming langagues. 'Keys' must always be surrounded by double quotes, followed by a colon, and then a value for that key. Commas are needed when separation separate sets of key-value pairs. 
            <pre>
                object.json     //file
                {
                    "key":  "value",
                    "key":  "value"
                }
            </pre>
        </p>
        <p>JSON is able to nest different properties to show an hierarchy of data so it's easier to read than other data formats. For Example: 
            <pre>
                user.json       //file name
                {
                    "username": "john.doe",     //initial object
                    "firstName": "John",
                    "lastName": "Doe",
                    "isFullTime":   true,
                    "position": "supervisor"
                    "permissions": ["view", "edit", "create", "delete"]     //nested array
                    "suboordinate": [{
                        "username": "jane.doe",     //nested object
                        "firstName": "Jane",
                        "lastName": "Doe",
                        "isFullTime":   false,
                        "position": "assistant"
                        "permissions": ["view", "edit", "delete"],
                        "suboordinate": [{
                            "username": "jane.doe",     //nested object within an object
                            "firstName": "Jane",
                            "lastName": "Doe",
                            "isFullTime":   false,
                            "position": "assistant"
                            "permissions": ["view", "edit", "delete"], 
                            "suboordinate": [...]
                    }]
                }
            </pre>
        </p>

        <h3>Parsing a JSON file in Javascript</h3>
        <p>Like in Javascript, array containers are brackets '[]' and you're able to include JSON in the HTML file as it's still valid Javascript. 
            Majority of the time, information requests are returned as strings and not as Javascript objects. To convert the use the built-in method of 'JSON.parse' with the declared variable as the parameter.
            <pre>
                &lt;body>
                    &lt;script type="text/javascript">
                        let companies = 
                        `[   //array of objects
                            {
                                "name": "Fresh Farms",
                                "numberOfEmployees": 5000,
                                "consumerRating": 4.2,
                                "employeeRating": 3.6
                            },
                            {
                                "name": "Hydro Fields",
                                "numberOfEmployees": 3500,
                                "consumerRating": null,
                                "employeeRating": 3.1
                            },
                            {
                                "name": "Sunshine Produce",
                                "numberOfEmployees": 2750,
                                "consumerRating": 3.2,
                                "employeeRating": 4.6
                            }
                        ]`

                        console.log(JSON.parse(companies)[0].name)  //will return name of first company
                    &lt;/script>
                &lt;/body>
            </pre>
            In order to get the information from the array as not an object, you would use backticks(`) around the array to have it logged as a string. Alternatively you can use the stringify method.
        </p>

        <h3>MongoDB & NoSQL</h3>
        <p>Databases are collections of organized and structured data that's stored electronically in a computer and provides high performance in accessing data. Databases allow for stored data where any changes persist and allow for the creation of dynamic applications.</p>
        <p>SQL stands for Structured Query Language that function as relational databases that stores data in tables and rows. NonSQL or No SQL are non-relational databases that store data in other formats besides tables.</p>
        <p><a href="https://www.mongodb.com/docs/manual/tutorial/install-mongodb-on-windows/">MongoDB</a> stores data as document objects and is classified as a non-relational database. By storing data as objects, this allows for flexibility with custom data structures that don't conform to tables and allows documents within same collections to have different fields.</p>
        <p>MongoDB is a NoSQL database structured to store data in a JSON-like document structure with a built-in query language designed to make data easy to access and scale.</p>
        <p>Binary JSON was developed for use by MongoDB to store JSON data that has been encoded into binary language and allows for the usage of data types JSON does not natively support(ie dates and binary values). BSON was developed add functionality to JSON by being more lightweight and easily traverseable.</p>
        <p>MongoDB allows users to create validation rules to avoid formatting variances due to different data sets.
            <pre>
                {_id: ObjectID("109e284fa3401984"),
                name: 'ReadyPlayerOne',
                type: 'Player',
                gender: 'Male',
            </pre>

            <pre>
                {_id: ObjectID("109e284fa335798"),
                name: 'Jarl Banzo',
                type: 'NPC',
                gender: 'Male',
                aggro: false
                catchphrase: 'Welcome to Bratwurst',
            </pre>

            Both documents can be in the same collection of 'characters'
        </p>
        <p>Mongo's Database Structure follows a tree structure. 
            <pre>
                Starting: Mongo -> Database -> Collection -> Document
            </pre>
            <ul>
                <li>Mongo can store many Databases where each database is comprised of many collections.</li>
                <li>Collections are a set of documents with parent-child relationships, similar to tables as containers.</li>
                <li>Documents are basic data types or units that function similar to rows of a table.</li>
            </ul>
        </p>
        
        <h3>MongoDB Compass and Queries</h3>
        <p>MongoDB can be installed on a <a href="https://www.mongodb.com/try/download/community?tck=docs_server">local</a> machine utilizing the terminal or a GUI like Compass where the data is also stored locally. There is also a cloud version of MongoDB called <a href="https://www.mongodb.com/try">Atlas</a> where the data resides online on MongoDB's servers.</p>
        <p>Connect to a local Mongo database on Compass.</p>
        <p>Compass is a MongoDB GUI to provide an interface for the user to interact with the Mongo database. Connection Strings identify the path to connect to specific databases.</p>
        <p>Compass UI Layout
            <ul>
                <li>Local Mongo Database List - displays database name, size, amount of collections, and indexes</li>
                <li>Host - displays Database location and port </li>
                <li>MongoSH Beta - built in Mongo shell terminal that makes it easy to manage and query data from a local machine database. </li>
            </ul>
        </p>
        <h4>MongoDB Compass Guide</h4>
        <ul>
            <li>If Compass isn't installed already, follow the documentation on their <a href="https://www.mongodb.com/try/download/community?tck=docs_server">site</a></li>
            <li>Open Compass and connect to Mongo via Connect button.</li>
            <li>MONGOSH is the terminal and can be accessed at the bottom of the app. 
                <ul>Terminal commands:
                    <li>'show dbs' - lists the local Mongo databases</li>
                    <li>'db' - will show current database</li>
                    <li>'use dbnamehere' - used to switch to the database, but if a database doesn't exist, Compass will create a new database then switch to it.</li>
                    <li>'db.createCollection('collectionName')' - Each database can have multiple collections that contains data similar to an array.</li>
                    <li>'show collections' - will list all collections contained within current database</li>
                    <ul>Terminal Commands with Methods: 
                        <li>'db.collectionName.insertOne()' - method that will create data by inserting a document under a collection with the specified name. Shift + Enter moves down a line.
                            <pre>
                                db.collectionName.insertOne({
                                    city: "North Hollywood",
                                    county: "Los Angeles",
                                    state: "California",
                                    country: "United States of America"
                                })
                            </pre>

                            <pre>
                                //will return following status/response
                                {
                                    acknowledged: true,
                                    insertedID: ObjectID("randomID value")
                                }
                            </pre>
                        </li>
                        <li>'db.collectionName.find()' - locates all documents within a collection similar to file explorer with search parameters. It's also considered an 'equality condition' which allows you to filter data according to a key and value pair.
                            <pre>
                                db.collectionName.find({ timezone: "GMT-5" })
                                //returns {_id: ObjectID("Assigned Number"), ... }
                            </pre>
                            If we didn't want every single key-value pair when we queried the data to avoid parsing large sets of data, we use projection and pass a second argument object to the .find() method. Object needs to include key(s) that have a value that functions as the filter for the field to omit or include to be returned in the query.
                        </li>
                        <li>Update Operations
                            <li>'db.collectionName.updateOne(arguments)' - command tells Mongo intention of updating document, needs at least two arguments as parameters.</li>
                            <li>'db.collection.updateMany(filter, update, options)' - updates all documents that match the specified filter for a collection
                                <pre>
                                    db.collection.updateMany(
                                        &lt;filter>,
                                        &lt;update>,
                                        {
                                            upsert: &lt;boolean>,
                                            writeConcern: &lt;document>,
                                            collation: &lt;document>,
                                            arrayFilters: [ &lt;filterdocument1>, ... ],
                                            hint:  &lt;document|string>        // Available starting in MongoDB 4.2.1
                                        }
                                    )
                                </pre>
                                <ul></ul>
                            </li>
                            <li>'db.collection.findAndModify()'</li>

                                <ul>Update Operators process document fields with string-based names in order. 
                                    <li>Query object that Mongo will use to find exact document to update</li>
                                    <li>Object that includes data to be updated in the document including update operator prefex.</li>
                                </ul>
                                <pre>
                                    //Example
                                    db.collectionName.updateOne(
                                        { city: "North Hollywood" },
                                        { $set: { city: "Burbank"} }
                                    )
                                </pre>

                                <pre>
                                    //will return following status/response
                                    { acknowledged: true,
                                        insertedID: null, 
                                        matchedCount: 1,
                                        modifiedCount: 1, 
                                        upsertedCount: 0 }
                                </pre>
                                <ul><a href="https://www.mongodb.com/docs/manual/reference/operator/update/#fields">Fields</a>
                                    <li>$currentDate - Sets the value of a field to current date, either as a Date or a Timestamp.</li>
                                    <li>$inc - Increments the value of the field by the specified amount.</li>
                                    <li>$min - Only updates the field if the specified value is less than the existing field value.</li>
                                    <li>$max - Only updates the field if the specified value is greater than the existing field value.</li>
                                    <li>$mul - Multiplies the value of the field by the specified amount.</li>
                                    <li>$rename - Renames a field.</li>
                                    <li>$set - Sets the value of a field in a document.</li>
                                    <li>$setOnInsert - Sets the value of a field if an update results in an insert of a document. Has no effect on update operations that modify existing documents.</li>
                                    <li>$unset - Removes the specified field from a document.</li>
                                </ul>
                                <ul><a href="https://www.mongodb.com/docs/manual/reference/operator/update/#operators">Array Operators</a>
                                    <li>$ - Acts as a placeholder to update the first element that matches the query condition.</li>
                                    <li>$[] - Acts as a placeholder to update all elements in an array for the documents that match the query condition.</li>
                                    <li>$[&lt;identifier>] - Acts as a placeholder to update all elements that match the arrayFilters condition for the documents that match the query condition.</li>
                                    <li>$addToSet - Adds elements to an array only if they do not already exist in the set.</li>
                                    <li>$pop - Removes the first or last item of an array.</li>
                                    <li>$pull - Removes all array elements that match a specified query.</li>
                                    <li>$push - Adds an item to an array.</li>
                                    <li>$pullAll - Removes all matching values from an array.</li>
                                </ul>
                                <ul><a href="https://www.mongodb.com/docs/manual/reference/operator/update/#modifiers">Array Modifiers</a>
                                    <li>$each - Modifies the $push and $addToSet operators to append multiple items for array updates.</li>
                                    <li>$position - Modifies the $push operator to specify the position in the array to add elements.</li>
                                    <li>$slice - Modifies the $push operator to limit the size of updated arrays.</li>
                                    <li>$sort - Modifies the $push operator to reorder documents stored in an array.</li>
                                </ul>
                                <li>$bit - Performs bitwise AND, OR, and XOR updates of integer values.</li>
                            </li>
                        </li>
                        <li>'db.destinations.deleteOne()' - only requires one argument. 
                            <pre>
                                db.destinations.deleteOne({ city: "Burbank" })
                            </pre>
                            <pre>
                                //will return following status/response
                                { acknowledged: true, deletedCount: 1 }
                            </pre>
                        </li>
                    </ul>
                </ul>
            </li>
        </ul>
    </section>

    <section> <!-- Mongoose & ODMs -->
        <h3>Mongoose & ODMs</h3>
        <p>ODMs are defined as Object Data Mappers. They help with model data while making document validation easier with built-in methods by providing structure and consistency to documents. They allow for queries and CRUD operations to perform within an application code instead of in the Mongo shell. </p>
        <p>'mongoose' is an npm package and also an ODM for MongoDB that simplifies interactions with a Mongo database within node apps by converting Mongo documents into Javascript objects and vice versa.
            <pre>
                JSX(Client application) &lt;--> node.js(server)/express(server) &lt;--> mongoose(server) &lt;--> mongoDB(database) 
            </pre>
        </p>
        <p>Install and connect Mongoose to an Express App in the 'server.js' file
            <pre>
                const mongoose = require('mongoose')
            </pre>
        </p>

        <h3>Mongoose Models and Schemas</h3>
        <p>Models are objects that provide access to the matching collections in Mongo. Mongoose models allow users to interact with the Mongo database.
            <pre>
                Ex: MongoDB Collection "Users" &lt;--> Mongoose Model "User"
            </pre>
        </p>
        <p>Schemas determine the structure of documents within a collection and function like a blueprint.</p>
        <p>Documents are the basic unit of data for Mongo while schemas are the basic building block in Mongoose. 
            <br>Creating a model based on Mongoose schema
            <pre>
                //require mongoose
                const mongoose = require('mongoose')
                const { Schema } = mongoose
                
                //defining schema syntax
                const userSchema = new Schema({
                    username: { type: String },
                    password: String    //same as declaring 'type: String'
                })

                //convert schema into model to interact with Mongo database
                const User = mongoose.model('User', userSchema)
            </pre>
        </p>
        <p>Schemas have built-in validators that are set as a property for a field's object. Built-in validators depend on the field type.
            <pre>
                Data Type       Available Validator
                All             required
                Number          min, max
                String          enum, match, minLength, maxLength
            </pre>

            Usage:
            <pre>
                const objectSchema = new Schema{(
                    name: {
                        type: String, 
                        required: true,     //'required:' property is a built-in validator 
                        min: [0, "Desired string for custom error message when validation fails"],
                        max: 25,        //multiple validators can be used on on one property
                        unique: true    //built-in helper option that checks if value is unique, it accepts the boolean value. If not, then false is the default.
                    }       
                })
            </pre>
        </p>
        
        <h4>Mongoose Helper Methods</h4>
        <p>Mongoose models are objects with built-in helper methods that can perform database actions thru using Mongoose.</p>
        <p>New Mongoose models will also generate an object and each object contains helper methods for performing database actions. Each model will link with a corresponding collection in Mongo (ex: User.findOne() will try to find a document within the Users collection). 
            <pre>
                const User = mongoose.model('User', userSchema)

                //Helper methods are similar to prebuilt methods or functions
                User.findOne()
                User.create()
                User.deleteOne()
                User.updateOne()
            </pre>

            Similar to functions, the parameter or argument passed to the method would still be the conditions for the action and once the action is completed, a promise where you can access the data is returned. 
            <pre>
                User.find({ age: 18 })
                    .then(foundUsers => {
                        console.log(foundUsers)     //returns users that are 18
                    })
            </pre>
        </p>

        <p>All helper methods can take additional arguments as options objects to customize an action as an optional argument. The available options will vary depending on the helper method that was used.
            <pre>
                Destination.find({}, [], { sort: { available_tickets: 4 } })    //{ sort: } is an options object to sort the returned data in ascending numerical order of available_tickets
            </pre>

            <pre>
                Destination.findByIDAndUpdate(req.params.id, { available_tickets: 0 }, { new: true })   //{ new: true } is another options object to return an updated document. 
            </pre>
        </p>

        <h3>Custom Helper Methods: Instance & Static Methods</h3>
        <p>Instance methods are methods that can only be used on instances of a model(document) and also only on documents that have been retreived from a database.</p>

        <p>Static methods are methods that can only be utlized on a model(collection) and able to be used prior to documents being retrieved from the database.</p>
        <p>
            <pre>
                Mongoose Term   -> Mongo DB Equivalent
                Instance        -> Document
                Model           -> Collection
            </pre>

            <pre>//Inside the models/user.js file
                const userSchema = new Schema({     //Define the schema
                    firstName: String,
                    lastName: String,
                    score: Number
                })

                userSchema.methods.fullName = function() {      //Defining instance method: userSchema(affected schema).methods(Mongoose keyword to define instance method).fullName(what to set method name to)
                    return this.firstName + this.lastName
                }

                userSchema.static.getHighScorers = function() {     //Defining static method: userSchema(affected schema).static(Mongoose keyword to define static method).getHighScorers(what to set method name to)
                    return this.find({ score: {
                        $gte: 1000 }})

                }
            </pre>
            
            <pre>//Inside the user_controller.js file 
                User.findByID(id)       //query collection for a user document
                    .then(foundUser => {
                        console.log(foundUser.fullName())   //invoke defined .fullName instance method
                    })

                User.getHighScorers()   //query collection using defined static method
                    .then(foundUsers => {
                        console.log(foundUsers)
                    })
            </pre>
        </p>
        <p>Use case for helper methods</p>

        <h3>Multiple Mongoose Models and Relationships</h3>        
        <p>Creating another model requires another schema that will create a second collection in Mongo.</p>
        <p>There are two common patterns for relating models together. 
            <ul>
                <li>Many-to-many relationship - Documents from one collection can have many doucments from another collection. They aren't excusive to each other and could be linked to other parent and children.</li>
                <li>One-to-many relationship - A document from one collection can exclusively include documents from another collection. Similar to how an object has a parent but the parent can have many children. Models can be related together by utilizing object IDs. One Model would have a schema field to hold the ID of the related model using parent-child references. 
                    <ul>
                        <li>The parent model has a related ID field Array to reference and link to all of its children.</li>
                        <li>The child model has the related "_id: ObjectID" field to reference to its parent.</li>
                    </ul>
                    <p>Syntax for a one-to-many relationship in Mongoose using ID reference.</p>
                    <ul>
                        <li>"Schema.Types.ObjectID:" defines the Mongoose the datatype for the field to be an ID.</li>
                        <li>"ref:" tells Mongoose which model the ID belongs to</li>
                        <pre>
                            //call Mongoose and the parent model
                            const mongoose = require('mongoose')
                            const Library = require('./library.js')
                            const { Schema } = mongoose

                            //create schema for books
                            const bookSchema = new Schema({
                                title: { type: String, required: true },
                                book: { type: Schema.Types.ObjectID, ref: 'Library'}
                            })
                        </pre>
                    </ul>                    
                </li>
            </ul>            
        </p>

        <h4>Mongoose Populate Method</h4>
        <p>".populate()" is Mongoose method that pulls in data from a referenced document by virtually replacing the reference ID field with the related data. The populate method can be used after any ".find" query method and should be used on the model that holds the reference ID field.
            <pre>// inside the "models/book.js" file
                Book.findOne({ title: 'All Star'})
                .populate('library')        //looks for linked id field by checking the argument for the reference field's name on the model on the model being queried
                .populate('author', 'name location')         //method can be chained onto a single query as needed with a second argument to specify fields
                .then(foundBook => {
                    console.log(foundBook)
                })

                //return Output
                {                    
                    _id: dba20841284ddgaa198025u908124,
                    title: 'Anyone Can Cook',
                    author: {       //returns the data from the referenced document query for 'author'
                        _id: dba52b5f4gsa54gsdf64ccas265344,
                        name: 'Auguste Gusteau',
                        location: France,
                        //debutYear: 1986 is omitted as the field wasn't specified to be included
                        
                    library: {      //returns the data from the referenced document query for 'library'
                        _id: dba52b36asdg464ccas265344,
                        name: 'Pixar',
                        releaseYear: 2007
                        
                    }                    
                }
            </pre>
            The populate method to pulls in related data in a one-to-many relationship.
        </p>
        <h4>Mongoose Virtuals</h4>
        <p>Virtuals are a way to create a nonpersistent virtual field onto Mongoose documents while not saving to the database. Use cases include: 
            <ul>
                <li>Computing Values - Calculating a value based on an existing field</li>
                <li>Combining Values - Combining existing fields</li>
                <li>Finding Related Docs - Populating the parent with its related children documents</li>
            </ul>
        </p>
        <p>Virtual fields do not appear in JSON results by default. In order to include them, there was be an option called toJSON on the schema.</p>
        <p>Basic Virtual Syntax
            <pre>
                //located in "models/user.js"
                userSchema.virtual('fullName')      //'fullName' is the set name for the virtual field
                .get (function() {
                    return `$(this.firstName) ${this.lastName}`     //defines what goes into the field
                }, { toJSON: { virtuals: true }})       //option to convert virtual field to JSON 

                //Virtual Expected Output:
                {
                    firstName: 'Terry'
                    lastName: 'Crews'
                    fullName: 'Terry Crews'     //argument is inserted here
                }
            </pre>
            <ul>
                <li>'userSchema' - schema on which virtual field is created</li>
                <li>'.virtual' - prebuilt method</li>
                <li>'fullName' - first argument used to name the virtual field</li>
                <li>'.get(function())' - method that allows you to get and transfrom document's data</li>
                <li>'.return[...]' - returns defined value set to the virtual field</li>
            </ul>
        </p>
        <pre>
            //creating the vitual, located in "models/library.js"
            librarySchema.virtual('books', {    //schema.vitual('books') follows usual virtual field syntax, {...} is the second argument defining values
                ref: 'Book',        // related schema model
                localField: '_id',      //matching field to the parent model 
                foreignField: 'library'       //reference field to the child model
            })

            //invoking populate on the model, located in "librarys_controller.js"
            Library.find()
                .populate('books')      //invoked populate where the argument passed is the name of the virtual field
                .then(foundLibrarys => {
                    res.send(foundLibrarys)
                })

            //Virtual fields and Populate method expected output
            {
                name: 'Harry Potter'
                Author: 'J. K. Rowling'
                books: [
                    {
                        name: 'Harry Potter and the Sorcerer's Stone'
                        releaseDate: 'June 26, 1997'
                    },
                    {
                        name: 'Harry Potter and the Chamber of Secrets'
                        releaseDate: 'July 2, 1998'
                    },
                    [ ... ]
                ]

            }
        </pre>
        <p>Virtuals are used to add temporary attributes to a document. Generally very useful for values that are constantly referenced. Custom Helper Methods on the other hand, are used when writing custom utility methods on a document. Good for things used often but not constantly.</p>
        
        <h4>Mongoose Hooks</h4>
        <p>Hooks are a way to allow for running custom code before or after an event happens.</p>
        <p>Subscription Anology; 
            <pre>Subscribing to a channel/newsletter saves or triggers based on a 'save' event -> new content is uploaded so the 'save' event is triggered -> view content runs custom code in hook</pre>
        </p>
        <p>'Pre Hook' would execute the custom code before the event it's following occurs. 'Post Hook' will execute the custom code after the event it's following. Hooks can subscribe to any <a href="https://mongoosejs.com/docs/middleware.html#types-of-middleware">database action</a>
            <li>Example Events: save, validate, find, findOneAndDelete, findOneAndUpdate</li>
            <pre>userSchema.pre('save', function() {        //'userSchema' is the name of the schema model the hook is linked to. '.pre' or '.post' hook will define when code is executed. 'save' is the first argument and event to follow. 'function(){}' is the second argument with the custom code that runs.
                console.log('This will trigger before saving a user document')
            </pre>
        </p>
        <p>MongoDB is not a relational database after all. You need to implement your own cleaning mechanism. If you remove documents as a parent, generally you delete referenced documents of it's children to avoid extraneous clutter in the database
            parent gets deleted. There are 2 ways
            <pre>
                //remove() mehtod is deprecated
                Person.pre('remove', function(next) {
                    // Remove all the assignment docs that reference the removed person.
                    this.model('Assignment').remove({ person: this._id }, next);
                });
            </pre>

            <pre>
                //Mongoose has created updates to provide hooks for deleteMany() and deleteOne(). These are best practice.
                Person.pre('deleteMany', function(next) {
                    var person = this;
                    person.model('Assignment').deleteOne({ person: person._id }, next);
                });
            </pre>
        </p>

        <h4>Mongoose Query Optimization</h4>
        <p>Mongoose is a Node.js Package that is written in JavaScript, so built-in modern functions such as async/await are still accessible
            <pre>
                //Mongoose Query with Promises
                app.get('/', (req, res) => {
                    Book.find()
                    .then(foundBooks => {
                        res.render('index', { users: foundusers })
                    })
                    .catch(err ->{
                        res.status(404).render('404')
                    })
                })
            </pre>
            <pre>
                //Mongoose Query with Async/Await
                app.get('/', async (req, res) => {
                    try {
                        let foundBooks = await Book.find()
                        res.render('index', { books: foundBooks })
                    } catch (e) {
                        res.status(404).render('404')
                    }
                })
            </pre>
        </p>
        <p>'limit' is a Query Option that limits the amount of documents returned. 'skip' is another Query Option that skips over the specified amount of documents. 
            <pre>
                //located in 'books_controller.js'
                let books = await Book.find({}, {
                    limit: 2        //limits returned document to 2
                    skip: 1     //skips the first document
                })
                console.log(books)
            </pre>
            
            <pre>
                //Expected output returned in the terminal
                [
                    {
                        //this document would be skipped
                        name: 'Harry Potter and the Sorcerer's Stone'
                        releaseDate: 'June 26, 1997'
                    },
                    {
                        name: 'Harry Potter and the Chamber of Secrets'
                        releaseDate: 'July 2, 1998'
                    },
                    {
                        name: 'Harry Potter and the Prisoner of Azkaban'
                        releaseDate: 'July 8, 1999'
                    }

                ]
            </pre>
        </p>        
        <p>'lean()' is a Query Option method that returns documents as plain JavaScript objects. 
            <pre>
                let users = await Book.find().lean
                console.log(books)
            </pre>
            When using the 'lean' method the queries are faster and less memory intensive, however there's no longer access custom helper methods or virtuals(with the exception of populate).
        </p>
        
        <h4>Mongoose Overview</h4>
        <p>'Mongoose' is a Node based Object Document Mapping(ODM) for MongoDB that acts as a translator between MongoDB and Javascript.</p>
        <p>'Schemas' are a Mongoose component that defines what the document looks like. They function like blueprints and can be used to make an indefinite amount of documents. Document validations are included in the schemas as a field's property.
            <ul>Data Type -> Available Validators
                <li>All -> required</li>
                <li>Number -> min, max</li>
                <li>String -> enum, match, minLength, maxLength</li>
            </ul>
        </p>
        <p>'Models' are Javascript objects created using schemas. By default, when a 'model' has been created, the object is generated with built-in helper methods that allow for typical CRUD actions. Models allow the user to interact with data in the Mongo Database.</p>
        <p>There are two types of custom helper methods.
            <ul>
                <li>Instance Methods - Best for utility cases such as combining multiple fields or converting a field's value.</li>
                <li>Static Methods - Best for writing custom queries such as queries that would be used multiple times across several routes like a list.</li>
            </ul>
        </p>
        <p>A 'one-to-many' relationship is described as a document that can own many other documents, and those owned documents cannot belong to any other collection.</p>
        <p>'Populate' is a query method that pulls in related data from a reference field. It should be used on a query and replaces the relevant reference field with related data.</p>
        <p>'Virtuals" are a way to create a 'virtual' field on a document that is used for computing, combining valuesm or creating fields for the related children documents.</p>
        <p>Hooks are used to subscribe to Mongoose events. Pre-Hooks runs custom code before the event while Post Hooks run after the event.</p>
    </section>

    <section> <!-- APIs & Documentation -->
        <h3>APIs & Documentation</h3>
        <h3>API</h3>
        <p>An application is comprised of the front-end interfrace and a back-end defined logic and servers. API stands for Application Programming Interface and is an interface that allows interaction between two applications.</p>
        <p>Describe how an API works using an analogy.</p>
        <p>Explain how endpoints are used to interact with an API.</p>


        <h3>RESTful APIs</h3>
        <p>REST stands for Representational State Transfer and is a set of design principles or a pattern for bulding web apps.
            <pre>
                Action -> HTTP METHOD -> Route
            </pre>
            HTTP is the client-server protocol of the web using requests and responses and is the basis for how data is exchanged on the web. 
        </p>
        <p>RESTful API's use RESTful routes which utilizes HTTP methods and they follow the same client-server communication model of HTTP.</p>
        <p>RESTful API's use JSON as the language to exchange data. 'res.json' is an Express method that will send responses back in JSON format by parsing anything passed to it as an argument and converting the argument to JSON.
            <pre>
                app.get('/', (req, res) => {
                    res.json({
                        greeting: 'Welcome Home!
                    })
                })
            </pre>
        </p>

    </section>

    <section> <!-- Cloud Deployment -->
        <h3>Cloud Deployment</h3>
    </section>

    <section> useEffect Hook -> dependency array stops the infinite loop as it expect nothing or state variables. it can be empty and is good practice to be empty for API calls.
        <pre>
            useEffect(() => {
                console.log('call useEffect');
              }); // by default useEffect runs after every re-render
            
            console.log('render here');            
        </pre>
    </section>
    
</body>
</html>